<!doctype html>
<html ng-app="runcode">
<head>
<title>Interactive JavaScript Tutorial</title>
<link rel="icon" type="image/png" href="/static/img/JavaScript-logo-64x64.png">
<link rel="stylesheet" href="/static/angular/angular-ui.min.css">
<link rel="stylesheet" href="/static/css/code.css">
<link rel="stylesheet" href="/static/codemirror/lib/codemirror.css">
<link rel="stylesheet" href="/static/codemirror/theme/neat.css">
<script src="/static/jquery/jquery-1.8.2.min.js"></script>
<script src="/static/codemirror/lib/codemirror.js"></script>
<script src="/static/codemirror/mode/javascript/javascript.js"></script>
<script src="/static/angular/angular.min.js"></script>
<script src="/static/angular/angular-sanitize.min.js"></script>
<script src="/static/angular/angular-ui.min.js"></script>
<script src="/static/js/app.js"></script>
<script src="/static/js/filters.js"></script>
<script src="/static/js/controllers.js"></script>
</head>
<body ng-controller="CodeCtrl">
<div id="content_container" ng-class="{'collapsed': contentCollapsed}">
  <div id="toc-trigger">
    <a href="http://developer.mozilla.org/" target="mdn_docs">MDN Docs</a> |
    <a href="http://w3schools.com/" target="w3schools_docs">W3 Schools Docs</a>
  </div>
  <div id="content-header">
    <h1>Interactive JavaScript Tutorial <span class="toc" ng-click="tocShowing = !tocShowing">&#x25bc;</span></h1>
    <div id="collapser" ng-click="contentCollapsed=true">&gt;&gt;</div>
    <div id="chapter-num">
      <a class="nav" ng-class="{'hidden': chapter <= 1}" href="#/{{prevChapter()}}">&#x25c0;</a>{{chapter}}<a class="nav" ng-class="{'hidden': chapter >= tutorials.length }" href="#/{{nextChapter()}}">&#x25b6;</a>
    </div>
  </div>
  <div id="toc" class="content" ng-show="tocShowing">
    <div id="toc-content" class="information">
      <ol>
        <li ng-repeat="t in tutorials"><a href="#/{{t.index + 1}}">{{t.title}}</a></li>
      </ol>
    </div>
  </div>
  <div id="slide" class="content" ng-show="!tocShowing">
    <div id="instructions" class="information">
      <h1>{{tutorial.title}}</h1>
      <div ng-bind-html="tutorial.description | linky | paragraphs"></div>
    </div>
    <div id="tutorial_nav">
      <a class="nav" ng-class="{'hidden': chapter <= 1}" href="#/{{prevChapter()}}">&#x25c0;</a>{{chapter}}<a class="nav" ng-class="{'hidden': chapter >= tutorials.length }" href="#/{{nextChapter()}}">&#x25b6;</a>
    </div>
  </div>
</div>
<div id="expansion_grabber" ng-class="{'expandable': contentCollapsed}" ng-click="contentCollapsed=false">&lt;&lt;
  <span class="chapter">{{chapter}}</span>
</div>
<div id="workspace" ng-class="{'fill': contentCollapsed}">
  <div id="workspace_actions" class="actions" ng-class="{'expanded': isExpanded}">
    <div>
      <a id="run" class="button" ng-click="runCode(code)">RUN</a><a id="more" class="button" ng-click="isExpanded = !isExpanded" ng-class="{'highlight': dirty()}">&#x25bc;</a>
    </div>
    <ul ng-click="isExpanded=false" class="more">
      <li ng-click="clearOutput()">Clear Output Window</li>
      <li ng-click="clearCode()">Clear Code Window</li>
      <li><hr></li>
      <li ng-click="revertCode()" ng-class="{'highlight': dirty()}">Restore Slide Code</li>
      <li ng-click="revertAll()" ng-class="{'highlight': dirty()}">Restore ALL Slides</li>
    </ul>
  </div>
  <div id="workspace_top">
    <textarea name="codetext" ui-codemirror="{lineNumbers: true, theme: 'neat', indentWithTabs: false, tabSize: 2, indentUnit: 2, extraKeys: {Tab: 'indentMore', 'Shift-Enter': doNothing } }" ng-model="code"></textarea>
  </div>
  <div id="workspace_bottom">
    <div id="output">
      <pre id="out" class="stdout">{{out}}</pre>
      <pre id="err" class="stderr">{{err}}</pre>
    </div>
  </div>
</div>
<div id="chapter-contents" style="display: none">
  <div name="Hello, JavaScript!">
    Welcome to JavaScript, a very useful language!

    Here we have a simple "Hello World!" program. Try running it now, either by
    clicking *Run*, or pressing *Shift-Enter*.

    JavaScript is an _imperative_ language, meaning that it does just what you
    tell it to, one thing at a time, in order. In this case, we have told it to
    do exactly one thing, which is to show an alert window containing the text
    |Hello, JavaScript!|. This text is called a *string* (of characters).

    Once you've tried out some exercises, navigate to other slides using the
    navigation arrows or the *Page-Up* and *Page-Down* keys.

    Exercises

    - Try running the program with a quotation mark missing. What happens? What
      if you swap |"| for |'| everywhere?

    - Change the string to say hello specifically to you.

    - Print 'Hello, JavaScript!' using two strings instead of one, like this:
      |alert('Hello ' + 'JavaScript!')|.

    --

    alert("Hello, JavaScript!");
  </div>
  <div name="Comments">
    JavaScript (and many other languages) ignores **comments**: bits of text
    that start with |//| and extend to the end of the line. They are strictly
    for humans to read, and do not affect how your program runs.

      // This is a comment.

    There is also a multi-line version, delimited with two special symbols:

      /* This is a
         multi-line
         comment. */

    These are customarily formatted as seen in the code window, with repeated
    asterisks and the terminator on a line by itself, but that is merely
    convention. What makes it a comment is the way it begins and ends.

    Comments are useful for making notes to yourself
    or others about how the program's code works.

    Note that comment delimiters like |//| or |/*| and |*/| have to stand alone
    syntactically to form a comment; if they appear within a string, then they
    are just part of the string.

    Exercises

    - Output a string with a comment delimiter inside of it, e.g., |alert("Not // a comment!")|.

    --

    // This is a line comment. Line comments start
    // with '//' and extend to the end of the line.

    /* This is a multi-line comment.
     * This formatting (with repeated asterisks) is
     * conventional. The comment terminator stands alone.
     */

    alert("This is not a comment.");
  </div>
  <div name="Variables">
    A **variable** is a place to remember something.
    You assign a value to a variable using the
    **assignment operator** (a single |=|) like this:

      var a = "hi";
      var A = "hello";

    Now the _variable_ |a| contains the _string_ |"hi"| and |A| contains
    |"hello"|. Yes, case matters: |a| is not the same as |A|.

    In JavaScript, variables spring into existence when they are declared with
    |var| *or* assigned a value. Before that they do not exist, and referring
    to them is an error (see the exercises). It is typical to declare and
    assign at the same time. Until more is explained later about when it is
    appropriate to omit it (hardly ever, it turns out), always use |var| when
    assigning a variable for the first time.

    A valid **variable name** can contain letters, numbers, and the characters
    |_| and |$|, but cannot begin with a number (it can also use a substantial
    set of Unicode characters, but we'll stick with plain ASCII for this
    tutorial). A variable can contain any kind of value.

    Exercises

    - Try assiging to a variable name that starts with a number
      (like |1eet|). See what happens.

    - Assign a new variable to an existing one, e.g.,
      |b = a|. Output it.

    --

    var a = "hi there";  // 'a' now contains a string of text.
    alert(a);

    // Here we *reassign* 'a' to contain a number. Note the lack of 'var'.
    a = 10;
    alert(a);

    // The $ is just another character. It has no special meaning.
    var $my_longer_varname = 14;
    alert($my_longer_varname);

    // Until assigned, variables do not exist.
    alert(i_dont_exist);
  </div>
  <div name="Numbers">
    JavaScript understands a few fundamental **types** of data. You have
    already encountered a couple of them, namely _strings_ like |"hello"| and
    _functions_ like |alert|. We'll get to functions later. For now, let's
    focus on numbers.

    You have already seen examples of numbers being assigned to variables, and
    it works fairly naturally. Numbers do pretty much what you'd expect them
    to. You can apply all of the basic mathematical operators to numbers:

      * Multiply
      + Add
      - Subtract
      / Divide
      % Remainder

    JavaScript represents all numbers in the same way underneath: as
    _double-width IEEE floating point_ numbers, but you won't need to know much
    about that for this tutorial. The important thing to know is that it knows
    how to treat numbers as integers, as well, and sometimes we'll lie a bit
    and pretend that it actually thinks of them that way.

    Exercises

    - Try adding |+| to the front of a number instead of |-|.

    - Try using the modulus operator |%| between a couple of integer numbers.
      What does it do?

    --

    // Normal decimal notation works great.
    var myInt1 = 15;
    var myInt2 = -25;

    // As does hexadecimal!
    var myInt3 = 0xdeadbeef;

    // Various styles of floating point are allowed,
    // including scientific notation.
    var myFloat0 = 1.0;
    var myFloat1 = 0.0423;
    var myFloat2 = 1e-5;
    var myFloat3 = 17.2e12;

    // Let's see what that hex number above looks like:
    alert(myInt3);

    // Now for some operators:
    alert(10 + 6);
    alert(15 - 21);
    alert(7 * 20);
    alert(7 / 12);

    // What is this value?
    var a = 3 + 50 * 2;

    // How about this?
    var a = (3 + 50) * 2;
  </div>
  <div name="Basic Syntax Rules">
    In the previous examples, we have taken it for granted that every statement
    ends in a semicolon. JavaScript is kind of funny this way, because strictly
    speaking, the semicolon is _not required_. There is a major caveat,
    however. Sometimes the computer can't tell whether you intend to end a
    statement or continue it.

    Because of this, strange and unexpected things can happen if you omit the
    semicolon. Consider the code window. There is an example of a case where
    JavaScript can figure out what you meant, and another where it cannot.

    There are many more such examples, so always be clear to the parser: use
    semicolons at the end of statements.

    Another important note: "whitespace" is not _usually_ significant. The
    indentation shown in these slides is for human consumption. The computer
    doesn't care about it. The same goes for blank lines, spaces between
    operators and numbers, between statements in function calls, etc.

    But this rule is not consistently applied. Where possible, JavaScript will
    insert a virtual semicolon for you at the end of a line if it thinks it
    can, and that can be tough to predict: it's best to just always use them.

    Exercises:

    - Before running the code, guess what the final output will be.

    --

    // This is fine. Not really ambiguous. Or is it?
    var a = "hi there"

    // This works, but it's sort of unclear that it should, because the end of
    // a line *usually* takes the place of a missing semicolon. This doesn't look
    // right to a human, but the parser handles it anyway. Many surprising errors
    // have been hidden by code just like this.
    var b = "hey "

        + "there"

    // It's even worse when you consider that the following is valid all by
    // itself. It produces the value 50.3, but the value is
    // immediately discarded:

    + 50.3

    // Therefore, so is this. Guess what it outputs.

    var c = "number "

    + 10

    alert(c);
  </div>
  <div name="String Escaping">
    There is no difference between |'| and |"| - they both form
    equivalent strings. People usually pick one based on preference,
    changing only to include quotes inside, like this:

      "Don't touch my quoting."
      'I need to "work", now.'

    Occasionally, you need to include both kinds of
    quotes inside of a string. In these cases, you can
    **escape** quotes using a backslash:

      "This string contains the \" delimiter."

    Strings accept other escape sequences, like |'\n'|, which inserts
    a line feed character, making a new line. More
    info can be found here:

    http://www.w3schools.com/js/js_strings.asp

    Exercises

    - Try creating a string that contains a backslash:
      it will need to be escaped.

    --

    var message = ("This has a double quote \" inside.\n" +
                   'This has a single quote \' inside.\n' +
                   "This has a second line:\n  Yup.");

    alert(message);
  </div>
  <div name="Calling Functions">
    We are now ready to explain something we have been using all along:
    function calls. JavaScript has a lot of stuff built in that you can just
    use, and it exposes most of it through functions that you can call.

    A function is called by placing parentheses after its name. If it accepts
    **arguments**, then they go inside as in |alert("Hello there!")|, which
    should look familiar.

    All JavaScript functions also **return** something. This means that, in
    addition to taking arguments _in_, they also send values _out_. To obtain
    the returned value of a function, just use that function call in place of a
    value, e.g., |a = parseInt("1723")| or |alert(parseInt("1723"))|.

    You can call some functions with more than one value. In that case, supply
    values separated by commas, e.g., |Math.pow(2, 10)| (more on that later).

    Functions like |alert| are only used for their effect, so they implicitly
    return the special value |undefined|. Another such function specifically
    defined for convenience in this browser-based presentation is |_output|. It
    accepts any number of arguments and outputs all of them, separated by
    spaces, in the output window.

    Exercises

    - Try adding the strings |"2000"| to |"1000"|. Now try adding the result of
      |parseInt("2000")| to |parseInt("1000")|. What happened? What is |parseInt|
      doing?

    - Convert the string |"3.14159"| into a floating-point number with
      |parseFloat|.

    - Peruse the reference material at
      https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects

    --
    // This evaluates to the number 2423, but it never used, so that value
    // is discarded.
    parseInt("2423");

    // This is unique to this course. It is not a standard JavaScript function,
    // but is provided for convenience as you monkey around.
    _output("Hello, output window.");

    // Note that alert evaluates to undefined:
    var alertOutput = alert("hello");
    _output("output of alert: " + alertOutput);

    // You can convert strings to numbers:
    var intVal = parseInt("42");
    var floatVal = parseFloat("2.718281828");

    // Note, we're kind of glossing over something big here: adding a string to
    // a value first converts that value to a string, then joins them together.
    _output("intVal", intVal);
    _output("floatVal", floatVal);
    _output("double floatVal", (2 * floatVal));

    // Finally, you can plug evaluated functions directly into the arguments of
    // other functions. Many of these functions are in their own namespace, and
    // are specified by the namespace and a dot. Math, for example, has many
    // interesting and useful functions:
    _output(Math.floor(3.14159));
  </div>
  <div name="Objects and More Math">
    Now that we know about function calls, we can talk about some of the more
    interesting mathematical operations that are not expressed as symbols, like
    taking a square root.

    But first we need to talk a tiny bit about **objects**. You can think of a
    JavaScript object as something that groups stuff that belongs together.
    This definition will become more precise in time, but for now that is good
    enough.

    To access the stuff within an object, you name the object, put a dot after
    it, and name the thing inside, like this:

      Math.floor(55.3)

    This calls the |floor| function that is held by the built-in JavaScript
    |Math| object. There are many such built-in objects with many useful
    functions inside, including things that manipulate strings, dates, times,
    numbers, and elements on a web page that hosts your JavaScript.

    Exercises

    - Compute |Math.floor(52.5)| and |Math.ceil(52.5)|. What do these do?
      What if you use negative numbers?

    - Try adding a new value to the Math object by setting it, e.g.,
      |Math.myAwesomeValue = 42;|. Did it work?

    --

    _output("pi =", Math.PI);
    _output("sin(pi/2) =", Math.sin(Math.PI / 2));

    // Uh-oh - why is this not exactly equal to 0.5?
    // The answer lies in the IEEE floating point definition. Some numbers
    // cannot be expressed perfectly in floating point.
    _output("cos(pi/3) =", Math.cos(Math.PI / 3));

    _output("sin(pi/3) =", Math.sin(Math.PI / 3));

    _output("tan(pi/3) =", Math.tan(Math.PI / 3));

    // Square roots work:
    _output("sqrt(2) =", Math.sqrt(2));

    // And you can take other roots using negative powers:
    _output("cube root of 3 =", Math.pow(3, -3));

    _output("4 to the 3rd power =", Math.pow(4, 3));

    // Wait, did you expect this? How big is this number?
    _output("sin(pi) =", Math.sin(Math.PI));
  </div>
  <div name="Everything is an Object">
    Remember how we said that objects are sort of like containers that hold
    stuff inside of them? Well, it turns out that in JavaScript, _everything_
    is an object, including things like strings and numbers. The *prototypes*
    of these objects are |String| and |Number|, respectively (capitalization
    matters).

    A function that operates on the object that holds it is typically called a
    **method** of that object. You'll see the terms used interchangeably
    sometimes.

    For now, let's explore the idea that everything is an object. Strings, for
    example, have a few very useful methods, as do numbers. Take a look in the
    code window for some examples.

    Exercises

    - Look at the documentation for String at
      http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String .
      Try a few methods in the code window.

    --

    // The "length" member of every string tells you how many characters it
    // contains.
    _output("Hi there!".length);

    // The "slice" method takes a starting index and an ending index, and
    // returns a string from start (inclusive) to end (exclusive).
    _output("0123456789".slice(2, 5));

    // The "split" method allows you to split a string up into words, and
    // accepts a delimiter.
    _output("1:b:%".split(":"));

    // Variables are just names for things like strings, etc., so you can
    // obviously call methods on them as well.

    // The "trim" method removes space from the beginning and end of a string.
    var s = "  A string with leading and trailing space.   ";
    var s_trimmed = s.trim();
    _output("'" + s_trimmed + "'");

    // When doing this trick with numbers, you need parentheses, otherwise
    // it looks like you're specifying a floating point because of the dot.
    // Note that many objects have a "toString" method.
    _output((253).toString());
  </div>
  <div name="Getting Help">
    There are a lot of functions available in JavaScript itself. You can find
    documentation for these at a couple of popular places.

      Official: http://developer.mozilla.org/
      Popular: http://www.w3schools.com/jsref

    In addition to what the language itself has to offer, JavaScript usually
    runs in a **hosted environment**, which will expose its own variables,
    types, and functions that you can use to manipulate that environment.

    One of the most common hosted environments is the web browser, though
    you can also run JavaScript without a browser in environments like
    "node.js". We'll focus mostly on the browser for this tutorial.

    The point is that there are so many functions and variables available
    that even seasoned developers do their work with the documentation open
    all the time. Don't hesitate to keep the documents in front of you when
    you are working on solving a problem.

    Since we work within the web browser most of the time, it is useful to
    know what that environment is called. It is referred to as the "Document
    Object Model" or "DOM". Documentation for the DOM is often found
    side-by-side with generic JavaScript documentation, and that is certainly
    the case for http://www.w3schools.com/jsref, as well as for the official
    http://developer.mozilla.org/ site.

    Exercises

    - Poke around the two sites above and see if you can find the JavaScript
      documentation.

    - Now look for DOM documentation. They're organized slightly differently
      but you should see some big similarities once you drill down a bit.

    --

    // What is this? No idea? Try looking it up!
    // Also, remember how you can use a function call anywhere a value is needed?
    // What does this "chained replace" do below?
    //   REMINDER: the left side of dots like these has to be an object.
    var a = "\tHello there\n".replace("\t", "&lt;tab&gt;").replace("\n", "&lt;newline&gt;");

    _output(a);
  </div>
  <div name="Equality, Null, and Ordering">
    Things are **equal** to each other if they have the _same values_. In
    JavaScript, testing for equality is done using the |==| operator, and
    inequality is tested with |!=|. As you might expect, |10 != "10"| (one is a
    Number, the other is a String), but |10 == 5 + 5| (both sides are numbers
    with the same value). The value of these operations is a *boolean value*,
    one of **true** or **false**.

    With variables, things get a little bit more interesting. Suppose you have
    two index cards, each with the number |5| on them. Each card is a
    _variable_, and the "5" written on them is their _value_. Because they have
    the same values, they are **equal** in the |==| sense: they contain the
    same data. But they are not the same card.

    Now suppose I write "5" on one card, show it to you, and say "This is |a|".
    Then I show you _the same card again_, but say, "This is |b|". In this
    case, |a| and |b| are equal in the |is| sense: they are not only equal (|a
    == b|), they are also referring to the same card (|a === b|). This normally
    does not matter much, but you will occasionally see |===| in use and should
    at least know what it means.

    Stretching the index card metaphor to the breaking point, there is a
    special value in JavaScript called **null**, and you can store it in any variable.
    Similarly, **undefined** is like having no index card at all, or a blank
    index card (though this is a gross oversimplification).

    Exercises

    - There are other comparison operators, and they
      do what you'd expect, even on strings and other
      sequences. Experiment with |&lt;|, |&lt;=|, |&gt;|, and
      |&gt;=| - see what happens when you print something
      like |5 &lt; 7| or |'hello' &gt;= 'hello there'|.

    --

    _output("Equality is squishy with strings and numbers.");
    _output("10" == 10);  // true
    _output("10" === 10); // false
    _output(10 == 5 + 5); // true

    _output("Variable assignment satisfies ===");
    var a = 1543;
    var b = a;

    _output(a == b);   // Obviously true - same data.
    _output(a != a+1); // Indeed.
    _output(a === b);  // Also true. Assignment satisfies '==='.

    // Performing an operation on data like numbers or
    // strings produces a *new thing*, even if the data is
    // the same.
    _output("Same data, might not be the same thingy.");
    b = a + 1 - 1 * 1.0;

    _output(a == b);   // Still true.
    _output(a === b);  // Might be true, might not, depending on the implementation.

    _output("not null:", a != null);  // A very common kind of test.
    var c = null;
    _output(c !== null);  // false
  </div>
  <div name="Sequences">
    You have already seen one kind of sequence: the String. You can access
    members of a string using the |[]| operator:

      "Hi there"[1] == "i"

    There are other sequences, as well. All sequences in JavaScript, like
    String, are _zero-based_, meaning their first element is element |0|.

    A very common sequence type is the **Array**, typically created thus:

      [1, 1, 2, 3, 5, 8]; // A 6-element array.
      [];                 // An empty array.

    If you look up Array in the JavaScript documentation, e.g., by looking up
    "mdn javascript array" on your favorite search engine or using the
    documentation links above, you will find that it has some useful properties.
    You can get the length of an array by accessing |.length|, access and even
    set its members using |[]|, add elements to the end using |.push|, join
    elements together in a single String using |.join|, sort elements using
    |.sort|, etc.

    Exercises

    - Look up the Array and see what kinds of functions and data elements it
      provides: http://www.w3schools.com/js/js_arrays.asp . Don't worry about
      reading and understanding all of it, just poke around there and in the JS
      Arrays Methods section.

    - Try setting setting values beyond the end of the array. What happens?

    --

    // Create an array:
    var a = [7, 3, 1, 9];
    _output(a);
    _output("a has", a.length, "elements");

    // Indexing works as expected.
    _output("third element", a[2]);
    _output("last element", a[a.length - 1]);

    // Arrays are *mutable*: they can be changed in place.
    a[3] = "hello";    // Change element 3.
    _output(a);

    // And you can push values onto the end
    // of them, among many other things.
    a.push("new value");
    _output(a);

    // Sorting is really useful.
    a.sort();
    _output("sorted", a);

    // Joining into a string is another.
    _output("joined", a.join("::"));

    // You can also take "slices" of an array.
    // What does this do?
    _output("sliced", a.slice(1, 4));
  </div>
  <div name="Objects as Dictionaries (Maps)">
    Up to this point, we have accessed the members of objects using dot
    notation, e.g., |a.length|. As it happens, members of objects can also be
    accessed and set using index notation: |a["length"]|. This makes the object
    act like a _dictionary_ or a _map_, which is a data structure that maps keys
    to values.

    This is very useful when you just want to keep track of a bunch of **keys**
    and **values**, and you don't necessarily know the keys beforehand.

    An object that is suitable for use in this way can be created using |{}|:

      {"name": "Mortimer", "age": 30}
      {} // An empty object.

    If the keys are valid JavaScript variable names, you can omit the quotes:

      {name: "Fred", food: "pizza"}

    To access these keys, you use indexing notation:

      var a = {};
      a["my key"] = 10;  // Set the value
      a["my key"] == 10; // Test: true

    Exercises

    - Try setting your own key/value pairs and outputting your dictionary.

    - Set a value with dot notation and print it with index notation.

    - Read about the built-in JSON object at
      https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON

    --

    var things = {
        "message": "something useless",
        "name with spaces": 15.23,
        3: "keys can be numbers"};

    // Wait, what is this?
    _output(things);

    // We're getting ahead of ourselves here, but this is
    // More likely what you expected to see:
    _output("JSON output:", JSON.stringify(things, null, "  "));

    _output("numeric index:", things[3]);
    _output("dot notation:", things.message);
    _output("spaces require indexing:", things["name with spaces"]);

    // You can set values in this object, as well:
    things["newval"] = "something completely different";
    _output(JSON.stringify(things));
  </div>
  <div name="Cool Pictures, and Learning is Forever">
    We just finished outlining the most important _data structures_ in
    JavaScript: arrays and objects. We also know how to find and call functions.
    This is a good time to take a breather and try to do something more
    exciting.

    Since we are working within a relatively modern browser (so long as it isn't
    IE 8 or earlier), we have access to the HTML 5 **canvas** element. Let's do
    something with one.

    When drawing on 2-dimensional canvas, the coordinate system is a little
    different than you might be used to. The upper-left corner is (0,0), and
    the lower-right corner is at (width-1, height-1). You are probably used to
    thinking of the y-coordinate as going the other direction, so this can take
    some getting used to.

    Take a look at the code in the code area. Note that _there are no new
    JavaScript ideas_ represented there. Everything there is something you
    already know how to do _with the language itself_. But it all looks
    unfamiliar! How could you possibly have known to write exactly that code
    to display some rectangles?

    Even seasoned programmers spend a lot of time with documentation open in
    front of them (I did that when creating this example, in fact!), because
    there is no way to remember it all, and things are constantly changing. They
    also spend a lot of their time **learning new things**, because every
    situation demands a new bit of knowledge. In this case, that new bit of
    knowledge is a bit of DOM manipulation and displaying stuff on a canvas.

    So, take heart! Once you know the _syntax_ of JavaScript, you can not only
    start grasping the vast _vocabulary_ of the language and its host
    environment, you can also _create your own_. We'll get into that shortly.

    Exercises

    - Look up canvas functions and try some different shapes.
      http://www.w3schools.com/tags/ref_canvas.asp

    --

    // Ask the DOM for the output window (where we have
    // been showing our output up until now).
    var container = document.getElementById("output");

    // Create a new DOM object: a canvas. Add it.
    var canvas = document.createElement("canvas");
    canvas.width = 200;
    canvas.height = 200;
    canvas.style.border = "1px solid black";
    container.appendChild(canvas);

    // To draw on a canvas, you need a "context".
    // We'll stick with a 2-dimensional context, here.
    var ctx = canvas.getContext("2d");
    ctx.fillStyle = "red";
    ctx.fillRect(10, 10, 50, 50);
    ctx.fillStyle = "blue";
    ctx.fillRect(70, 30, 100, 150);
  </div>
  <div name="Making Functions">
    You have already encountered a non-built-in function in these lessons:
    |_output|. This is a function that I wrote to make it easy to see what is
    going on without having to open an |alert| window. In the code window
    you can see that we call |_output(_output)|. This basically instructs
    the _output function to print a string version of itself. Check it out.

    There is a lot in there that we haven't covered yet, and some stuff that is
    specific to my use of AngularJS (http://angularjs.org/), so don't worry
    about understanding it in depth right now.

    The point is that _I made that_, and you can make your own functions, too.
    To define your own function, we'll start with the named version:

      function myFunc(a) {
        // Your stuff goes here.
      }

    Defining a function is as simple as using the |function| keyword, giving it
    a name, indicating what arguments it expects to receive (in the above case,
    just one called |a|), and putting the **body** in curly brackets.

    If you want to return a value other than |undefined| when the function is
    called, use the |return| keyword. There are examples of this in the code
    window.

    Exercises

    - Write a function that accepts two strings and returns them as one string
      separated by ":". HINT: you know how to join strings using |+|, and you can
      accept multiple arguments by separating them by commas in the function
      definition like so |function name(arg1, arg2)|.

    - Try the special |_canvas()| function that I provide with this tutorial to
      get a context more easily. You can pass it an optional width and height if
      you want.

    --

    // Let's peek inside, shall we?
    _output(_output);

    // Make your own!
    function timesFifteen(x) {
      return x * 15;
    }
    _output("3 times 15:", timesFifteen(3));

    // Some functions don't need to return anything.
    function myAlert(message) {
      _output(message);
      alert(message);
    }

    myAlert("alerts and displays");

    // This is useful: make canvas creation easier:
    function simpleCanvasContext() {
      var container = document.getElementById("output");
      var canvas = document.createElement("canvas");
      canvas.width = 200;
      canvas.height = 200;
      canvas.style.border = "1px solid black";
      container.appendChild(canvas);
      return canvas.getContext("2d");
    }

    var ctx = simpleCanvasContext();
    ctx.fillStyle = "green";
    ctx.fillRect(40, 50, 60, 70);
  </div>
  <div name="If Only">
    Programs are not very interesting if they always do the same thing and ignore
    the state of the world around them. One important way to respond to outside
    stuff is _conditionals_. The most common conditional is the *if statement*.

      if (test) {
        // Do stuff if "test" true.
      } else {
        // Do stuff if "test" is false.
      }

    The above is a basic |if else| structure. We encountered the _boolean
    values_ **true** and **false** before, and now we can use them to change
    the behavior of our programs. If the condition inside |()| evaluates to
    **true**, then the first block executes, otherwise the second block
    executes.

    The |else| part is optional. You can omit it if you don't need it.

    Exercises

    - Write a function that displays a red rectangle if its argument is |true|,
      and a blue rectangle otherwise.

    - Read this short post on JavaScript _truthiness_:
      http://james.padolsey.com/javascript/truthy-falsey/

    --

    function perkyBoolean(arg) {
      if (arg) {
        _output("Yes!");
      } else {
        _output("That's okay! I'm happy anyway!");
      }
    }

    perkyBoolean(true);
    perkyBoolean(false);

    // Any boolean expression can be used in the if statement above.
    perkyBoolean(10 == 5);
    perkyBoolean(15 &gt; 12);

    // If statements actually evaluate their condition
    // in a *boolean context*. In a nutshell, this means
    // that they try really hard to convert any value into
    // a true or false before proceeding. This can have some
    // surprising effects:
    perkyBoolean("");  // false - empty string
    perkyBoolean("0"); // true - non-empty string
    perkyBoolean(0);   // false - numeric zero
 </div>
  <div name="Introduction to Recursion">
    Functions are really neat, and the ability to define your own changes
    the game entirely. One thing that may not be obvious is that functions
    can _call themselves_. When a function ends up calling itself, either
    directly or indirectly, it is called _recursion_. Functions that do this
    _recur_ (they do _not_ "recurse" -- that's what _I_ do when I hear that word
    again and again).

    Now that we have conditionals and composite data structures, we can pretty
    much do anything we want to. The stuff that remains is icing and optimization.

    Let's see if we can use this to add up all of the elements of an array:

      var a = [2, 3, 5, 7, 11]; // Some primes
      function sum(arr) {
        if (arr.length == 0) {
          return 0;
        }
        return arr[0] + sum(arr.slice(1));
      }

    Whoa. Do you see what we did there? An empty array is defined as having sum
    of |0|. But a non-empty array is has the sum of its first element and the
    sum of the rest of its elements. Seems logical, but does it work?

    It turns out that it does! You can define functions that _depend on their
    eventual definition_. This is an incredibly powerful concept, and as alluded
    to earlier, is powerful enough that you don't need anything other than what
    you have learned to do arbitrary things with computers.

    If you want to understand how this works, think of it this way: when the
    JavaScript interpreter encounters a function call (call that "inner") inside
    of another function (call that "outer"), it suspends "outer" where the call
    occurs, calls "inner", and then resumes "outer" where it left off with the
    "inner" value where it belongs.

    That's a lot of words to say "it does what you would pretty much expect, and
    you can trust it".

    Exercises

    - Fix the use of |sum| when it is given strings. HINT: add an argument to
      |sum| called |default| that specifies the "base case". If |default ===
      undefined|, you can set it to 0 and proceed, otherwise use it in the right
      place.

    --

    function sum(arr) {
      if (arr.length == 0) {
        return 0;
      }
      // Not specifying the second argument of slice
      // implies "all the way to the end".
      return arr[0] + sum(arr.slice(1));
    }

    _output(sum([1, 2, 3, 4, 5]));
    _output(sum([2, 3, 5, 7, 11]));
    _output(sum([1, 1, 1]));

    // This *almost* works! What's wrong with it?
    // The exercises invite you to fix it. Give it a try.
    _output(sum(["hi", " ", "there", " folks!"]));

    // This one creates an array with every integer up
    // to but not including 'n' in it. How does it work?
    function range(n) {
      if (n == 0) {
        return [];
      }
      // We could also just return
      // range(n - 1).concat([n - 1]);
      var a = range(n - 1);
      a.push(n - 1);
      return a;
    }

    _output(range(10));
  </div>
  <div name="While Loops">
    We have seen how to use recursion to visit and operate on every element of
    a list, and that's a very powerful _functional_ approach to the problem.
    Lisp users rejoice! JavaScript, however, is an _imperative_ language, and
    as such it is more common to use a **loop** to modify a variable to achieve
    the same end.

    A loop is a body of code that is conditionally executed over and over
    again. Let's have a look at the simplest of these loops: the |while| loop.

      while(condition_expression) {
        // do stuff
      }

    When JavaScript enters a loop like this, it immediately tests the
    condition. If it's true, it proceeds to execute the loop's body. If false,
    it skips the whole thing. It's a lot like an |if| statement, with the
    difference that it goes back and evaluates the condition again after it
    finishes with the body. In other words, it evaluates the body over and over
    again while the condition is true.

    A related loop is the |do|-|while| loop, written thus:

      do {
        // do stuff
      } while (condition_expression);

    The difference is that this always executes at least once. It's not super
    common, but is occasionally useful to know.

    Exercises

    - Thought exercise: what happens if the |while| condition never becomes
      |false|? (Note, if you are fiddling with this, you might have to kill
      this browser tab and reopen it to fix it).

    - Make a loop that populates an array with the numbers 0 through 17 and
      then prints it.

    --

    var i = 0;
    while (i &lt; 10) {
      _output(i);
      i++;  // New concept! See below.
    }

    // What is this i++ thing all about?
    // It's the "postincrement" operator, and it basically adds 1 to i.
    // If you set something equal to it, that thing gets the value of i
    // *before* the increment.
    var a = i++;
    _output("postincrement", a, i);

    // There is a corresponding "preincrement" operator, which *also*
    // adds 1 to i, but increments i *first*, and then lets you assign
    // a variable to it.
    a = ++i;
    _output("preincrement", a, i);
  </div>
  <div name="For Loops">
    A much more common kind of loop is the |for| loop. It looks something like this:

      for (var i = 0; i &lt; 10; i++) {
        // do stuff with i
      }

    It consists of three parts:

    - Initialization (|var i = 0|)

    - Test (|i &lt; 10|)

    - Increment (|i++|)

    All of them are optional, and they can be any kind of statement (or list of statements).

    It is equivalent to this |while| loop:

      var i = 0;
      while (i &lt; 10) {
        // do stuff with i
        i++;
      }

    The |for| loop is more compact and puts important inforamtion (like how the
    condition is ever going to become false) right up front where you can
    glance at it. For these reasons, it is the most popular loop in JavaScript
    by far.

    Exercises

    - See if you can use a |for| loop to populate an array with the numbers 3 through 20.

    --

    for (var i = 0; i &lt; 5; i++) {
      _output(i);
    }

    // A common idiom for iterating over elements of an array or
    // an array-like thing (particularly if you are working with
    // the DOM, where getting the length can be expensive and
    // should not be done every time through the loop) is this:
    var arr = [2, 3, 5, 7, 11, 13];
    for (var i = 0, len = arr.length; i &lt; len; i++) {
      _output(i, arr[i]);
    }

    // Note how the initialization has two parts to it, separated by commas.
    // That's part of how |var| declarations work. We declare and assign two
    // variables at once that way.
  </div>
  <div name="More For Loops">
    There is another type of |for| loop that is quite common, and that is the
    |for|-|in| loop. This loop lets you iterate over all of the keys in an
    object, or all of the indices in an array (which is in a lot of ways the
    same thing).

    It looks like this:

      for (var key in object_of_interest) {
        // do stuff with key
      }

    The order is not guaranteed to be meaningful for object keys, but it will
    be in order for array indices.

    Exercises

    - Try something crazy, like iterating over all of the fields in the
      top-level DOM |document| variable.

    - What about the DOM |window| variable?

    - What happens if you try to also output the *values* of |window|?

    --

    // A for-in loop that iterates over the indices
    // in an array (not the values!).
    _output("array loop");
    var a = [2, 3, 5, 7, 11, 13];
    for (var k in a) {
      _output("  ", k, a[k]);
    }

    // A for-in loop that iterates over the keys
    // in an object (again, not the values!).
    _output("object loop");
    var o = {"a": 1,
             "b": 3,
             "name": "thing"};

    for (var k in o) {
      _output("  ", k, o[k]);
    }
  </div>
  <div name="Boolean operators">
    As we work more with loops and conditionals, we'll be using boolean operators.
    Recall that JavaScript's truthiness means "if it isn't |""|, |0|, |null|, |undefined|, or
    |false|, it's considered true".

    There are three very common and important boolean operations that we need to
    cover: |!|, ##||##, and |&amp;&amp;|.

    |!| is boolean "not" (inverse):

      !false == true
      !true == false

    |&amp;&amp;| is boolean "and" (conjunction):

      false &amp;&amp; false == false
      false &amp;&amp; true == false
      true &amp;&amp; false == false
      true &amp;&amp; true == true

    ##||## is boolean "or" (disjunction):

      false &amp;&amp; false == false
      false &amp;&amp; true == true
      true &amp;&amp; false == true
      true &amp;&amp; true == true

    Note that with these last two, there is an important caveat: if both values
    are truthy, |&amp;&amp;| returns **the second value** (not just |true|).

    Similarly, ##||## returns **the first truthy value**. Examples of this are
    in the code window.

    Exercises

    - Play around with the "returns second value" nature of |&amp;&amp;|.

    --

    // Boolean AND:
    _output("f and f =", false &amp;&amp; false);
    _output("f and t =", false &amp;&amp; true);
    _output("t and f =", true &amp;&amp; false);
    _output("t and t =", true &amp;&amp; true);

    // Spacer
    _output();

    // Boolean OR:
    _output("f or f =", false || false);
    _output("f or t =", false || true);
    _output("t or f =", true || false);
    _output("t or t =", true || true);

    _output();

    var a = null;
    // Since 'a' is null, b gets the next value.
    var b = a || "hello";
    // Since 'b' is not null, c gets b.
    var c = b || "hi";

    _output("a", a);
    _output("b", b);
    _output("c", c);
  </div>
  <div name="Checkpoint: Sorting with Loops and Recursion">
    It's time to apply what we have learned. If anything in this chapter is
    unclear, this would be a great time to go back and review.

    With that, let's talk about sorting. If you were to imagine a simple
    sorting algorithm, you might come up with the following:

    - Find the smallest element of the array,

    - Swap it with the first non-sorted element, and

    - Do it all again with the next non-sorted element until finished.

    This is called a _selection sort_, and it is indeed simple and effective.
    It is also fairly slow: every element that goes into it's correct location
    requires a scan of the remaining elements. This is basically quadratic
    behavior (for a list of size |n|, it takes about |n*n| steps).

    What if you tried a _divide and conquer_ approach like **Quicksort**
    instead? Here's how it works:

    - Divide the list into two pieces, one where everything is bigger than the
      first element, and one where every element is smaller (or equal).

    - Sort those two pieces and recombine them.

    This is better. A list half the size can take 1/4 the steps to selection
    sort. Cutting the list in half over and over again means that we never have
    to do the selection sort at all: eventually we end up with tiny
    already-sorted lists. The work done is |n * log(n)| for this algorithm.

    Implementations of both sorts are provided in the code window.

    Exercises

    - Spend some time understanding all of the code in the code window. Don't
      worry, it's less than it appears! Also, note that absolutely none of it
      is new at this point. You have learned every concept displayed there.
      If some of it seems unfamiliar, go ahead and review a few concepts. The
      rest of the tutorial will assume that you are comfortable with this slide.

    - Try turning the explanations above into pictures of what is going on. It
      might help to draw an array somehow and label pieces of it, then step
      through the idea on paper.

    - Check out these animations of various sorting algorithms. The ones we
      have looked at are "Selection" and "Quick":
      http://www.sorting-algorithms.com/

    - Try removing all of the comments and see how small the algorithm really is.

    --

    // These will be helpful in counting how much
    // work each algorithm does.
    var selection_compare_count = 0;
    var qsort_compare_count = 0;

    function selection_sort(arr) {
      var len = arr.length;
      for (var end_of_sorted = 0; end_of_sorted &lt; len; end_of_sorted++) {
        // Find the smallest value in the unsorted part.
        var smallest_position = end_of_sorted;
        for (var i = end_of_sorted + 1; i &lt; len; i++) {
          selection_compare_count++; // let's see how much work we did.
          if (arr[i] &lt; arr[smallest_position]) {
            smallest_position = i;
          }
        }
        // Now we know where the smallest value is: swap.
        var temp = arr[smallest_position];
        arr[smallest_position] = arr[end_of_sorted];
        arr[end_of_sorted] = temp;
      }
    }

    // When implementing recursive algorithms, this
    // is a common pattern: a main function that acts
    // as the entry point, and a helper that does the
    // real work but has more arguments.
    function qsort(arr) {
      _qsort_helper(arr, 0, arr.length);
    }

    // This is the real worker, the recursive part that calls itself
    // with different sections of the array.
    function _qsort_helper(arr, start, end) {
      // Here is our basis case: an array with 1 or fewer
      // elements is trivially already sorted, so we're done.
      if (end - start &lt;= 1) {
        return;
      }

      // First we pick a "middle" value. We don't know
      // beforehand what the range is, so we just make
      // a blind assumption that the first element is
      // somewhere in between the lowest and highest.
      var mid = arr[start];

      // We will leave that right where it is, at the front.
      // When the next step is complete, we'll move it to
      // the "center" of the two lists where it belongs.

      // Now, get all of the smaller values on the left
      // side of it. We do this by remembering the position
      // of the last not-properly-placed value (begins at
      // start + 1, since mid is sitting at start) and
      // walking down the array from start to end looking for
      // something smaller. If we find one, we swap it in
      // and advance the position.
      var start_of_larger = start + 1;
      for (var i = start_of_larger; i &lt; end; i++) {
        qsort_compare_count++; // let's see how much work we did.
        if (arr[i] &lt; mid) {
          if (i != start_of_larger) {
            // Found one not already in the right place.
            // Swap it into the right spot.
            var temp = arr[i];
            arr[i] = arr[start_of_larger];
            arr[start_of_larger] = temp;
          }
          // We just got one into the right place, so we can
          // move on to the next one.
          start_of_larger++;
        }
      }

      // Now we have all of the smaller elements to the
      // left of start_of_larger, and all the larger
      // elements to the right of it. The only one out of
      // place is "mid". Fix that now, moving it to one
      // before start_of_larger:
      var temp = arr[start_of_larger - 1];
      arr[start_of_larger - 1] = arr[start];
      arr[start] = temp;

      // Now we have basically got two lists. We sort each side.
      // And we do so using this very function!
      // Note that we leave the mid alone. It's already in the right spot.
      _qsort_helper(arr, start, start_of_larger - 1);
      _qsort_helper(arr, start_of_larger, end);
    }

    // Let's try it out!
    var a = [5, 2, 6, 3, 9, 10, 22, 5, 1, 3, 0.1, -3,
             23, -5, 28, 8, 11, 19, 33, 27, 13, 18];
    var b = a.slice(0); // Create a copy of a.

    selection_compare_count = 0; // reset before running
    selection_sort(a);
    _output("selection sort (" + selection_compare_count + " comparisons):", a);

    qsort_compare_count = 0; // reset before running
    qsort(b);
    _output("quicksort (" + qsort_compare_count + " comparisons):", b);

  </div>
  <div name="Function Arguments">
    So far we have mostly focused on functions that take a fixed number of
    arguments. We have seen an example or two where you can *omit* arguments
    when calling a function, and they will take on the value **undefined**
    within it.

    It turns out that you can have a function accept an *arbitrary* number
    of arguments, as well, by using the special |arguments| sequence within a
    function. You may have noticed that the implementation of |_output| uses
    this trick (try running |_output(_output)| again and take a look).

    Check out the code window for examples of how function arguments work.
    Also, this is worth reading: http://www.w3schools.com/js/js_function_parameters.asp.

    Exercises

    - Write a function like |_output| that joins an arbitrary number of
      arguments together into a string, with ':' as the separator.

    --

    // Functions can have trailing arguments omitted, or
    // explicitly set to undefined:
    function fixed(a1, a2, a3) {
      _output("a1:", a1, "a2:", a2, "a3:", a3);
    }

    // Omitting trailing arguments:
    fixed("hi");
    fixed("hi", "there");

    // Specifying some as undefined:
    fixed(undefined, "and", "stuff");

    // You can send more than was asked for, but the extras
    // are simply ignored.
    fixed(1, 2, 3, 4, 5);

    // Functions can take arbitrary arguments:
    function arbitrary(a1, a2, a3) {
      _output("arbitrary a1:", a1, "a2:", a2, "a3:", a3);
      // Note that even though we name a1, a2, and a3, they are repeated
      // in the arguments sequence. For this reason, functions that use
      // it don't typically have any listed in the header.
      for (var i = 0, len = arguments.length; i &lt; len; i++) {
        _output("  arg " + i + ":", arguments[i]);
      }
    }

    arbitrary("hey", "there");
    arbitrary("1", "2", "3", "4", "5");
  </div>
  <div name="Functions are Closures">
    Functions in JavaScript are **closures**. This is a rather technical term,
    but the concept is fairly simple. The idea is that while a function can
    access the variables and arguments defined _inside_ of it, it can also
    access the variables defined _globally_ and _in the surrounding scope_.

    It helps to remember that functions are objects, just like everything
    else in JavaScript, and they can therefore be assigned to variables and
    passesd around and everything. In fact, you can create a function using a
    **function expression**: a nameless function that is created on the fly:

      var myFuncVar = function(arg1, arg2) {
        // do stuff here
      };

    The code window shows an example of how this works. Though there is not
    much code there, it will likely take a little bit of time to fully
    understand what is going on. It helps to think of it this way: when a
    function is _defined_, JavaScript packages up all of the environment around
    that function and allows that function to access and change that
    environment any time it is _called_ later on.

    Exercises

    - Remember the global counter variables we used in the quicksort slide a
      little while ago? Go back and see if you can move them into a closure
      instead. HINT: once you do this properly, you won't have to reset them
      before sorting anymore - that will happen inside the sort function (which
      will declare the counter, create a closure that uses it, call it, and
      return the count).

    --

    // This function makes a new function and returns it.
    function make_a_closure(a, b) {
      var inside_counter = 0;
      // Here we create a function without a name.
      // See how we just say "name = function(args)"?
      var f = function(message) {
        // We can access this because it's in the surrounding
        // scope. What's more, it belongs to the function
        // *definition*, so it lives longer than this function call.
        inside_counter++;
        _output("f (count " + inside_counter + "): " +
                "a", a, "b", b, "message", message);
      }; // note the semicolon: this is the end of a variable assignment
      // "f" is just an object that happens to
      // be a function, so we create it here and return it.
      return f;
    }

    var c1 = make_a_closure("a1", "b1");
    var c2 = make_a_closure("a2", "b2");

    // Watch what happens to the counter.
    c1("hi 1");
    c1("hi 1");
    c1("hi 1");

    c2("hello 2");
    c2("hello 2");

    c1("hi 1");
  </div>
</div>
</body>
</html>
